# 哈希

## 1. 两数之和-简单

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

【解析】

法一：

```
暴力解法，双层for循环，O(n^2)
```

```
遍历数组，把这些数一个一个拿出来，先拿出第一个A来问，
target-A这个差在map里吗（O(1)复杂度）
如果不在，把这个A连带着它的下标存到map,很显然第一个数肯定要存进去。
轮到B的时候，map里放了A.
轮到C的时候，map里放了A,B.
轮到D的时候，map里放了A,B,C.
按这个规律可以发现，不管map里放多少，我都只需要O(1)复杂度就能查出来有没有复合要求的数在里面。
所以只需要遍历一次。
```

## 49.字母异位词分组-中等

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

【解析】

```
思路：
  最主要的如何判断他们是异位词？？？？？？？？？？？
  把字符串变成字符数组
  对字符数组进行排序
  排完序在转回字符串，比较，一样就是异位词！！！

  然后就是使用map来查找key,key一样的就是异位词，就把这个异位词添加进map对应的key的value
  这个value是个list

  最后返回一个list,把map的values全放进去。
```

## 128.最长连续序列-中等

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

【解析】

```
* 第一步：
* 把这个数组元素全部扔进HashSet去重，去重是一个目的。
* 还有一个目的是为了查找元素复杂度O(1)
*
* 我们题目要找最长连续数列的长度。
* 问题就转化为我们要找到最长连续数列。
* 问题就转化为我们要找到这个序列的头儿。
* 只要找到头儿，头一直+1+1，挨个找就能找到尾巴。
* 那头儿的标志是什么？
*
* 如果这个X,在HashSet里找不到X-1,也就是没有比它更小的了。
* 意味着X要么是孤儿，要么他就是序列的头儿。
* 然后我们再while循环找X+1,一直到找不到为止，找到序列的尾巴。
* 过程中计数，算出序列长度。
* 然后之前我们必须记录一个最大长度。
* 然后这两个长度比较的最大值才是最终的最大长度。
*
* 回到上一段分析的开头，那这个X要是在HashSet里找到了X-1说明什么？
* 说明它不是这个序列头啊。
* 直接跳过就行了。
```

# 双指针

## 283.移动零-简单

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

【解析】

