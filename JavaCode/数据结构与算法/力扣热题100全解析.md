# 哈希

## 1. 两数之和-简单

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

【解析】

法一：

```
暴力解法，双层for循环，O(n^2)
```

```
遍历数组，把这些数一个一个拿出来，先拿出第一个A来问，
target-A这个差在map里吗（O(1)复杂度）
如果不在，把这个A连带着它的下标存到map,很显然第一个数肯定要存进去。
轮到B的时候，map里放了A.
轮到C的时候，map里放了A,B.
轮到D的时候，map里放了A,B,C.
按这个规律可以发现，不管map里放多少，我都只需要O(1)复杂度就能查出来有没有复合要求的数在里面。
所以只需要遍历一次。
```

## 49.字母异位词分组-中等

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

【解析】

```
思路：
  最主要的如何判断他们是异位词？？？？？？？？？？？
  把字符串变成字符数组
  对字符数组进行排序
  排完序在转回字符串，比较，一样就是异位词！！！

  然后就是使用map来查找key,key一样的就是异位词，就把这个异位词添加进map对应的key的value
  这个value是个list

  最后返回一个list,把map的values全放进去。
```

## 128.最长连续序列-中等

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

【解析】

```
* 第一步：
* 把这个数组元素全部扔进HashSet去重，去重是一个目的。
* 还有一个目的是为了查找元素复杂度O(1)
*
* 我们题目要找最长连续数列的长度。
* 问题就转化为我们要找到最长连续数列。
* 问题就转化为我们要找到这个序列的头儿。
* 只要找到头儿，头一直+1+1，挨个找就能找到尾巴。
* 那头儿的标志是什么？
*
* 如果这个X,在HashSet里找不到X-1,也就是没有比它更小的了。
* 意味着X要么是孤儿，要么他就是序列的头儿。
* 然后我们再while循环找X+1,一直到找不到为止，找到序列的尾巴。
* 过程中计数，算出序列长度。
* 然后之前我们必须记录一个最大长度。
* 然后这两个长度比较的最大值才是最终的最大长度。
*
* 回到上一段分析的开头，那这个X要是在HashSet里找到了X-1说明什么？
* 说明它不是这个序列头啊。
* 直接跳过就行了。
```

# 双指针

## 283.移动零-简单

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

 

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

【解析】

```
/**
 * 这道题的话看长相有点像冒泡。
 * 你看这个思路就应该是什么呢？
 * 遍历这个数组，如果你是0的话，就跳过去。
 * 如果你不是0，就往上也就是往左冒泡。
 * 说冒泡是因为形象一些，实际上的话就是循环换位置。
 * 这里需要注意的问题就是：
 * 比方说你1冒泡到顶上了。
 * 那你第二个非零的数3往上冒泡就不能冒泡到最顶，就得在1下边。
 * 那怎么实现呢？
 * 比较简单，就是每次循环到非0的数就记一次。
 * 还是比较好理解。
 * 下面就写一下实现。
 * 实现过程中发现，冒泡的过程中不需要逐个交换位置，直接换一次就可以了。
 * 因为当前非0的数到上一个非0的数之间一定全是0.
 *
 * 按moveZeroes2提交有报错，原因是没有控制边界条件。
 * 第二次提交错误，原因是交换位置没有按正常程序走，想当然了。
 */
 
 其实这种排序不是冒泡，是快排。
 但是思路上应该是冒泡的，因为冒泡才能保证非0的数顺序不变。
 有空再研究一下快排，忘了什么样了。
```

## 11.盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

示例1：

![image-20240304173456512](力扣热题100全解析.assets/image-20240304173456512.png)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

【解析】

```
/**
 * @create: 2023-09-27
 * 自己做出来了哈哈哈哈！
 * 解析：
 * 首先力扣上上是写了这道题是用双指针解题的，所以提前如果知道双指针会比较容易
 * 双指针顾名思义就是2个指针，一般都是左右2个，向内收缩
 * 1. 双指针从两边向内移动
 *      发现：
 *      如果从长边向内收缩，长方形面积只会减少，永远不会增加（因为容器高度由短边决定，而宽度在减少）
 *      所以：
 *      要想求最大面积，必须从短边收缩
 * 2. 从短边收缩后，求出面积s2,与之前的s1比较，取更大值
 * 3. 停止条件： 下标重合
 * 4. 返回最大值
 *
 */

/**
 * @Date:2024-03-04
 * 解析：
 * 第一，这道题首先要知道是双指针。
 * 第二，面积=底边×高
 * 指针移动的过程当中必须找到确定性。
 * 在这里确定性是什么？
 * =移动长边面积永远是减少的=
 * =只有移动短边才可能获取更大面积=
 *
 * 分析为什么：
 * 1. 向内移动长边的时候，只有两种情况
 *    -如果下一条变长，那么高不变，底边变短，则面积减少
 *    -如果下一条变短，那么高减小，底边变短，则面积减小
 * 2. 向内移动短边的时候也是这两种情况
 *    -如果下一条变长，那么高增加，地板变短，面积不一定如何变化
 *    -如果下一条变短，那么高较小，底边变短，面积减小
 * 所以只能向内移动短边才有机会获得更大面积，才能“遍历”到所有可能是最大面积的情况。
 * 
 */
```

## 15.三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

【解析】

