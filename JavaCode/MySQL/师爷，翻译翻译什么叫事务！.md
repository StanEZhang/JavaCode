老规矩，每次学这种新概念一定要去学一下简单的英语，因为这种从没见过的、翻译过来的新概念往往让人摸不着头脑：事务？什么事务？明明踏马的是交易！
事务的英文是**transaction**，英文语境下的意思是**交易或者转移**，应用于金融和商业领域，设计货币、商品、服务等的互换。然后在计算机领域进行引申扩展，尤其在数据库管理和分布式系统中，含义为一系列操作作为一个整体被执行，要么全部成功，要么全部失败，以保证数据的完整性和一致性。
所以让我们忘记狗屁事务，记住**transaction-交易**。
你要说为什么人家都用事务就你用交易？首先，我这不是交易，我这是transaction，其次，这个交易让我更好更直观的理解所谓“事务”的本质。当然了，为了沟通顺畅，事务这个概念还是要使用，只是在脑子里要知道它的本质还是交易二字。
**transaction-交易**具有4个基本特征：

- 原子性（Atomicity）：**交易**要么全部成功，要么全部不成功。
- 一致性（Consistency）：**交易**状态的最终改变必须满足我们的预期或规则。
- 隔离性（Isolation）：多个**交易**并发不会互相影响。
- 持久性（Durability）：**交易**提交成功，就是永久的。

在继续学习**transaction**之前，我们需要知道，研究transaction的意义在于解决某个或某类问题，所以我们先了解并总结一下人们到底遇到了什么问题。
# 并发访问导致的数据读取问题

1. 脏读
2. 可重复读
3. 幻读

在了解这三种问题之前再先看一张图，学一下英语。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/25734432/1701261056573-251b4064-9cce-4a51-9289-c0ad68b00017.png#averageHue=%23fafaf9&clientId=u740bc2ec-819d-4&from=paste&height=182&id=u31b1625a&originHeight=250&originWidth=874&originalType=binary&ratio=1.375&rotation=0&showTitle=false&size=26471&status=done&style=none&taskId=u653ae8c1-83bb-4e48-9f53-62ee15be36a&title=&width=635.6363636363636)

1. Read uncommitted 读了未提交的数据
2. Read committed 和Read uncommitted正好相反
3. Repeatable read 可重复读
4. 串行化

然后聪明的我们从图中总结一下几点：

- 脏读的原因是Read uncommitted
- Read committed 解决了脏读的问题，但有不可重复读的问题
- Repeatable read解决不可重复读的问题
- Serializable提供最高隔离级别，解决所有并发访问问题
# 四种隔离级别
我们继续进一步分析，帮助理解记忆：
**脏读：**
脏读的原因是读取了未提交的数据**Read Uncommitted**，数据原本为n, A交易读取了B交易未提交的修改后后数据m, 但B报错回滚m又变回了n, A读到的却是m.这条m数据就是脏数据。
怎么解决脏读？
Read committed, 交易只能读取已经被其他交易提交的更改。
**不可重复读：**
我们解释一下unRepeatable read, 就是做不到Repeatable read，而Repeatable read的意思前后读取的数据一致，那什么情况会造成前后读取的不一致呢？
我们必须知道到了不可重复读这里，我们是已经解决了Read uncommitted，也就是现在是**Read committed**，我们的交易持续一上午，9点读一次余额，11点读一次余额，但中间还有个别的交易（取了2000块）在10点钟的时候2分钟做完了（committed），那我九点钟读余额还有2000，11点读就没钱了，这合理吗？这不合理。
这就是不可重复读。怎么解决？那当然就是变成可重复读就行了。
**Repeatable read**这个级别保证在整个交易期间可以多次读取同一数据并获得相同的结果，即使其他事务试图对这些数据进行修改。
这通过锁定读取的数据行来实现，防止其他交易修改它们。
下面说解决了不可重复读，还会产生幻读。
**幻读：**
幻读是发生在“我明明都已经是可重复读了”之后。
我8点的时候读数据一共100条，等到9点时候再读变成2w条了，就跟闹鬼了一样，这就是幻读，怎么解决？
锁表。所有交易一个个排队进行，谁也别干扰谁。（**Serializable**）
这样做的问题显而易见，太慢了。所以基本不用。

前边的交易主要针对**数据库数据管理的事务讲解**和**ACID中的隔离性的讲解**。

下面说一下实际开发中代码实现层面对于事务的控制。
# Spring事务
Spring的事务管理实际上还是建立在底层数据库事务机制之上的。
通过 Spring AOP 切面技术，在合适的地方开启事务，接着在合适的地方提交事务或回滚事务，从而实现了业务编程层面的事务操作。
关于Spring事务控制主要说一下事务传播机制即可。
[《spring事务传播机制》](https://www.yuque.com/u25361986/dp30lg/ylng0nzbq736gq7p?singleDoc# 《spring事务传播机制》)
# 分布式事务
