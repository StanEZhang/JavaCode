## 项目一：柜员权限管理系统



## 项目二：半岛资讯（黑马头条）

### 1. 登录功能

#### 1.1 什么是JWT？

JWT是Json Web Token的缩写，由Header、Payload、Signature三部分组成，每部分中间使用点（.）分隔。

①Header头部包括令牌的类型（即JWT）及使用的哈希算法，将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。

②Payload是存放有效信息的地方。

③Signature这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。

#### 1.2 登录功能实现

```java
// 1.处理普通用户登录
// 1.1 根据用户名查询用户，判断是否存在
// 1.2 比对登录密码与表中的密文密码
// 1.3 比较失败，响应密码错误
// 1.4 比较成功，根据用户id生成TOKEN（有现成的工具类）

// 2.处理游客模式登录
// 直接为用户按照0生成TOKEN
```

#### 1.3 全局过滤器实现jwt校验

<img src="面试项目准备.assets/image-20220530113214612.png" alt="image-20220530113214612" style="zoom: 80%;" /> 

```java
// 1.获取request和response对象

// 2.判断是否是登录接口，是直接放行
// 3.非登录接口，获取token

// 4.判断token是否存在，不存在返回401(无权访问)
// 5.判断token是否有效，无效返回401(无权访问)

// 6.放行
```





### 2. 自媒体端图片素材管理

**需求：**图片上传的页面，首先是展示素材信息，可以点击图片上传，弹窗后可以上传图片。

#### 2.1 获取登录用户信息

自媒体中文章，素材需要和当前用户关联，可以加统一拦截器处理。

<img src="面试项目准备.assets/image-20220530114537923.png" alt="image-20220530114537923" style="zoom:80%;" /> 

①：wemedia-gateway网关进行token解析后，把解析后的用户信息存储到header中。

```java
// 在全局过滤器实现jwt校验时，第6步放行前，从token的载荷里取出登录用户ID，设置到请求头里，最后放行

//获取TOKEN载荷里的用户ID
String userId = String.valueOf(claimsBody.get("id"));
//将用户ID设置到请求头
request.mutate().header("userId",userId);
```

②：拦截器和ThreadLocal组合使用

在 heima-leadnews-common中提供了 拦截器对象 TokenInterceptor，拦截器中从Header中取出用户id存入当前线程（用ThreadLocalUtil）。

③：微服务拦截器整合使用

配置WebMvcConfig使拦截器生效，拦截所有的请求。

#### 2.2 素材上传实现

```java
        //1.判断参数合法性
        if(multipartFile==null || multipartFile.isEmpty() || multipartFile.getSize()==0){
            return ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID, "文件参数非法");
        }

        //2.判断用户是否登录
        Integer userId = ThreadLocalUtil.getUserId();
        if(userId==null){
            return ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
        }

        //3.为文件生成唯一名称  a.b.c.png
        String filePrefixName = UUID.randomUUID().toString().replace("-",""); //文件前缀名
        //原始文件名
        String originalFileName = multipartFile.getOriginalFilename();
        int lastIndex = originalFileName.lastIndexOf("."); //获取最后一个.的索引位置
        String filePostFixName = originalFileName.substring(lastIndex); //文件后缀名（扩展名）
        String fileFullName = filePrefixName + filePostFixName;//完整文件名

        //4.将文件上传到MinIO
        try {
            String url = fileStorageService.uploadImgFile("", fileFullName, multipartFile.getInputStream());

            //5.构建素材实例并保存
            WmMaterial wmMaterial = new WmMaterial();
            wmMaterial.setUserId(userId);//登录用户ID
            wmMaterial.setUrl(url); //访问路径
            wmMaterial.setIsCollection(0);//未收藏
            wmMaterial.setType(0);//图片类型
            wmMaterial.setCreatedTime(new Date());
            this.save(wmMaterial);

            //6.响应数据
            return ResponseResult.okResult(wmMaterial);
        } catch (IOException e) {
            e.printStackTrace();
            return ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, "文件上传失败");
        }
```

#### 2.3 素材列表查询实现

```java
    @Override
    public ResponseResult list(WmMaterialDto dto) {
        //1.设置分页参数默认值
        dto.checkParam();

        //2.判断用户是否登录
        Integer userId = ThreadLocalUtil.getUserId();
        if (userId == null) {
            return ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
        }

        //3.拼接查询条件
        LambdaQueryWrapper<WmMaterial> lambdaQueryWrapper = new LambdaQueryWrapper();
        lambdaQueryWrapper.eq(WmMaterial::getUserId, userId);//固定查询条件：用户ID
        if(dto.getIsCollection()!=null){
            lambdaQueryWrapper.eq(WmMaterial::getIsCollection, dto.getIsCollection());//动态查询条件：收藏字段
        }
        lambdaQueryWrapper.orderByDesc(WmMaterial::getCreatedTime);//查询结果根据创建时间倒排序

        //4.执行分页查询
        IPage<WmMaterial> page = new Page<>(dto.getPage(),dto.getSize());

        this.page(page, lambdaQueryWrapper);

        //5.封装分页响应结果实例
        ResponseResult responseResult = new PageResponseResult(dto.getPage(), dto.getSize(), page.getTotal());
        responseResult.setData(page.getRecords());//当前页列表数据

        //6.响应数据
        return responseResult;
    }
```

**【注意！！！】**注意分页功能要起作用，必须在自媒体引导类中天mybatis-plus的分页拦截器。





### 3.自媒体文章发布

#### 3.1 实现思路分析

<img src="面试项目准备.assets/image-20220530155453927.png" alt="image-20220530155453927" style="zoom:80%;" /> 

#### 3.2 功能实现

```java
        // 第一部分：准入控制-判断用户是否登录
        // 第二部分：创建或修改文章
        // 1.1 复制dto给wmNews
        // 1.2 判断如果是自动布局设置布局方式临时为空
        // 1.3 处理封面图片，将参数中的图片列表数据转为逗号分割的字符串
        // 1.4 创建或更新文章
               //如果ID为空，表示需要创建文章数据
               //如果ID不为空，表示需要删除关联关系及修改文章
               //1.删除关联关系
               //2.判断文章是否存在
               //3.如果存在就更新文章
        // 准备：抽取内容的图片列表
        // 第三部分：保存内容图片与文章关系
        // 第四部分：保存封面图片与文章关系

		// ***第五部分：审核自媒体文章内容（见下面第4部分）
		responseResult = auditWmNews(wmNews, contentImageList);
        if(responseResult!=null){
            return responseResult;
        }
        // 第五部分：审核自媒体文章内容（线程池优化后）
        wmNewsAuditService.auditWmNews(wmNews, contentImageList);

```





### 4.自媒体文章审核

#### 4.1功能实现

```java
//第一部分：准备文章的全部文本和全部图片地址
        //1.1 抽取全部文本
        String text = extractText(wmNews);
        //1.2 找到全部的图片地址并去重
		//1.3 ORC识别图片中的文本加入到待审核的1.1中的全部文本中（Tess4j）

// 在用阿里云审核之前先进行DFA本地敏感词库（确定有穷自动机）审核，可以节省资金
        //1.查询全部敏感词数据
            // 优化
            // 1.1先从Redis缓存中查询敏感词列表
            // 1.2如果查询不到，再从数据库表查询，设置到Redis缓存中
        //2.将敏感词初始化到DFA词库中
        //3.将文本拿到DFA词库中进行匹配得到MAP
        //4.根据MAP结果处理
      
//第二部分：调用阿里云文本检测接口进行审核
//第三部分：调用阿里云图片检测接口进行审核

//第四部分：根据发布时间决定是否创建APP文章
        //如果发布时间大于系统当前时间，则设置文章状态为自动审核通过，不创建APP文章
        //如果发布时间小于等于系统当前时间，则创建APP文章且设置文章状态为已发布
       
        //***调用feign接口创建或更新APP文章信息
        saveApArticle(wmNews);
   
```

#### 4.2文章审核系统优化（异步线程池）

①在wemedia的config包里添加线程池类ThreadExecutorConfig（注解：@Configuration，@EnableAsync //开启异步调用）

②将审核的代码抽取到单独的类中处理，并且审核方法要返回值为void，这样异步才能生效，文章审核业务实现类的审核方法添加注解@Async("taskExecutor")，对应我们自定义线程池中的 @Bean("taskExecutor") ，表示使用我们自定义的线程池。

③在WmNewsServiceImpl将第五部分的调用方式改为调用WmNewsAuditService的审核方法

#### 4.3审核通过后app端文章同步（feign）

①保存文章信息 ap_article

②保存文章配置信息 ap_article_config

③保存文章内容 ap_article_content

【功能实现】

①：在heima-leadnews-feign-api中新增接口IArticleClient

②：在heima-leadnews-article中实现该方法

```java
@RestController
public class ArticleClient implements IArticleClient {

    @Autowired
    private ApArticleService apArticleService;

    @Override
    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) {
        // saveArticle为新增方法
        return apArticleService.saveArticle(dto);
    }
}
```

③：在ApArticleService中新增方法saveArticle，然后再在实现类中完成保存功能

```java
        //1.复制dto给apArticle
        //2.根据ID判断，如果无值就创建APP文章相关数据
            //保存ap_article数据
            //保存ap_article_content数据
            //保存ap_article_config数据
    
        //3.如果ID有值，就更新APP文章相关数据
            //查询ap_article判断是否存在
            //查询ap_article_content判断是否存在
            //更新ap_article
            //更新ap_article_content

        //***4.异步调用生成文章详情的HTML页面(4.4添加)

        //4.响应APP文章ID
        return ResponseResult.okResult(apArticle.getId());
    }
```

④：在heima-leadnews-wemedia服务中已经依赖了heima-leadnews-feign-apis工程，只需要在自媒体的引导类中开启feign的远程调用即可

注解为：`@EnableFeignClients(basePackages = "com.heima.apis")` 需要指向apis这个包

#### 4.4FreeMarker异步生成app文章详情HTML 存入minIO

```java
        //1.为Freemaker模板准备MAP数据
        Map map = new HashedMap();
        map.put("content", JSONArray.parse(content));
        //2.生成HTML
        //3.将html写入到MinIO中获取URL
        //4.将URL更新到文章的static_url中
```

  

### 5.自媒体端文章上下架

#### 5.1 功能实现

```java
    //1.判断用户是否登录
    //2.判断文章是否存在
    //3.判断文章是否已发布状态
    //4.修改enable值

    //5.生产消息到MQ中（5.2kafka添加步骤）
    Map map = new HashedMap();
    map.put("articleId",wmNews.getArticleId()); //APP文章ID
    map.put("enable", dto.getEnable()); //自媒体文章上下架状态
    kafkaTemplate.send(WmNewsMessageConstants.WM_NEWS_UP_OR_DOWN_TOPIC, JSON.toJSONString(map));

    //5.响应数据
```

#### 5.2 消息通知article端文章上下架

①在wemedia, article模块下导入kafka依赖

②在自媒体端的nacos配置中心配置kafka的生产者

③在自媒体端文章上下架后发送消息（见5.1补充）

④在article端的nacos配置中心配置kafka的消费者

⑤在article端编写监听，接收数据

```java
/**
 * app文章上下架MQ监听器
 */
@Component
public class ArticleDownOrUpListener {

    @Autowired
    private ApArticleConfigMapper apArticleConfigMapper;


    @KafkaListener(topics = WmNewsMessageConstants.WM_NEWS_UP_OR_DOWN_TOPIC)
    public void msgReceive(ConsumerRecord<String,String> consumerRecord){
        Optional<ConsumerRecord<String, String>> optional = Optional.ofNullable(consumerRecord);
        optional.ifPresent(x->{
            Map map = JSON.parseObject(x.value(),Map.class);
            Long articleId = Long.valueOf(map.get("articleId")+""); //app文章ID
            Integer enable =  Integer.valueOf(map.get("enable")+""); //自媒体文章上下架状态
            Boolean isDown = true; //已下架
            if(enable==1){
                isDown = false; //已上架
            }

            //根据articleId更新apArticleConfig表的isDown字段的值

            apArticleConfigMapper.update(null, Wrappers.<ApArticleConfig>lambdaUpdate()
                    .eq(ApArticleConfig::getArticleId, articleId) //更新条件
                    .set(ApArticleConfig::getIsDown, isDown) //要更新的字段和值
            );
        });
    }
}
```

### 6.自媒体端延迟精准发布

#### 6.1延迟队列服务提供对外接口

①提供远程的feign接口，在heima-leadnews-feign-api编写类如下：

```java
package com.heima.apis.schedule;

import com.heima.model.schedule.dtos.Task;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

@FeignClient("leadnews-schedule")
public interface IScheduleClient {

    /**
     * 添加任务到DB和CACHE中
     * @param task
     * @return
     */
    @PostMapping("/api/v1/schedule/addTask")
    public long add(@RequestBody Task task);


    /**
     * 从REDIS的当前任务队列拉取任务
     * @param type
     * @param priority
     * @return
     */
    @PostMapping("/api/v1/schedule/pollTask/{type}/{priority}")
    public Task pollTask(@PathVariable("type") int type, @PathVariable("priority") int priority);
}
```

②在heima-leadnews-schedule微服务下提供对应的实现

```java
package com.heima.schedule.feign;

import com.heima.apis.schedule.IScheduleClient;
import com.heima.model.schedule.dtos.Task;
import com.heima.schedule.service.TaskService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ScheduleClient implements IScheduleClient {

    @Autowired
    private TaskService taskService;

    @Override
    /**
     * 添加任务到DB和CACHE中
     * @param task
     * @return
     */
    @PostMapping("/api/v1/schedule/addTask")
    public long add(@RequestBody Task task){
        return taskService.addTask(task);
    }

    @Override
    @PostMapping("/api/v1/schedule/pollTask/{type}/{priority}")
    public Task pollTask(@PathVariable("type") int type, @PathVariable("priority") int priority){
        return taskService.poll(type,priority);
    }
}
```

#### 6.2发布文章集成添加延迟队列接口

①将wemedia微服务中WmNewsAuditServiceImpl的saveApArticle(WmNews WmNews)方法由private变更为public，并在WmNewsAuditService中添加saveApArticle接口

②在wemedia微服务中创建WmNewsTaskService，WmNewsTaskServiceImpl实现

```java
package com.heima.wemedia.service.impl;

import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.heima.apis.schedule.IScheduleClient;
import com.heima.common.redis.CacheService;
import com.heima.model.common.enums.TaskTypeEnum;
import com.heima.model.schedule.dtos.Task;
import com.heima.model.wemedia.pojos.WmNews;
import com.heima.utils.common.ProtostuffUtil;
import com.heima.wemedia.service.WmNewsAuditService;
import com.heima.wemedia.service.WmNewsService;
import com.heima.wemedia.service.WmNewsTaskService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Slf4j
@Service
public class WmNewsTaskServiceImpl implements WmNewsTaskService {

    @Autowired
    private IScheduleClient scheduleClient;

    @Autowired
    @Lazy
    private WmNewsAuditService wmNewsAuditService;

    @Autowired
    private WmNewsService wmNewsService;


    @Override
    public void addTask(WmNews wmNews) {
        Task task = new Task();
        task.setTaskType(TaskTypeEnum.WM_NEWS.getTaskType());//任务类型
        task.setPriority(TaskTypeEnum.WM_NEWS.getPriority());//任务优先级
        task.setExecuteTime(wmNews.getPublishTime().getTime());//任务执行时间（文章的发布时间）
        task.setParameters(ProtostuffUtil.serialize(wmNews)); //任务参数

        scheduleClient.addTask(task);
    }

    @Autowired
    private CacheService cacheService;

    /**
     * 从redis的当前任务队列拉取任务
     */
    @Scheduled(cron = "*/5 * * * * ?")
    @Override
    public void listenerPublishWmNews() {

        String lockName = "lock:poll:publish:news";
        String lock = cacheService.tryLock(lockName, 3 * 1000);

        if(StringUtils.isNotBlank(lock)){
            log.info("[listenerPublishWmNews]获取到分布式锁，开始执行拉取任务");

            //1.根据类型和优先级从Redis当前任务队列拉取任务
            Task task = scheduleClient.pollTask(TaskTypeEnum.WM_NEWS.getTaskType(), TaskTypeEnum.WM_NEWS.getPriority());

            if(task!=null){
                //2.从任务中获取wmNews
                byte[] wmNewsBytes = task.getParameters();
                WmNews wmNews = ProtostuffUtil.deserialize(wmNewsBytes, WmNews.class);

                int count = wmNewsService.count(Wrappers.<WmNews>lambdaQuery()
                        .eq(WmNews::getId, wmNews.getId())
                        .in(WmNews::getStatus, WmNews.Status.ADMIN_SUCCESS.getCode(), WmNews.Status.SUCCESS.getCode())
                );
                if(count>0){

                    //3.创建远程APP文章数据
                    wmNewsAuditService.saveApArticle(wmNews);


                    //4.修改自媒体文章状态为已发布
                    WmNews wmNewsDB = new WmNews();
                    wmNewsDB.setId(wmNews.getId());
                    wmNewsDB.setStatus(WmNews.Status.PUBLISHED.getCode());
                    wmNewsDB.setReason("已发布");
                    wmNewsService.updateById(wmNewsDB);
                }
            }
        } else {
            log.error("[listenerPublishWmNews]未获取到分布式锁"  );
        }


    }
}
```

③最后在WmNewsAuditServiceImpl的审核方法最后第四部分内，添加异步任务的调用

```java
   
    @Autowired
    private WmNewsTaskService wmNewsTaskService;
   
    @Override
    /**
     * 自媒体文章自动审核
     * @param wmNews
     * @param contentImageList
     * @return
     */
    @Async("taskExecutor")
    public void auditWmNews(WmNews wmNews, List<String> contentImageList) {
        //省略。。。。。。。。。
        
        //第四部分：根据发布时间决定是否创建APP文章
        //如果发布时间大于系统当前时间，则设置文章状态为自动审核通过，不创建APP文章
        if(wmNews.getPublishTime().getTime()>System.currentTimeMillis()){
            wmNews.setStatus(WmNews.Status.SUCCESS.getCode());//自动审核通过，待发布
            wmNews.setReason("自动审核通过，待发布");
            wmNewsService.updateById(wmNews);

            //添加异步任务
            wmNewsTaskService.addTask(wmNews);
        } else { 
            //省略。。。。。。。。。。。
        }
    }
```





## 项目三：九点钟

### 1.企业信息管理

![image-20220703171909180](面试项目准备.assets/image-20220703171909180.png) 

#### 1.1企业基本信息查询

根据当前管理员登录时选择的企业ID, 查询企业基本信息用于页面回显。 这个企业ID, 我们只需要在服务端通过ThreadLocal获取用户信息, 然后提取企业ID即可,无需页面传递参数。

![image-20220703172051584](面试项目准备.assets/image-20220703172051584.png) 

点击基本信息，回显企业信息，请求路径为：http://localhost:10010/sys/company

<img src="面试项目准备.assets/image-20220703172209711.png" alt="image-20220703172209711" style="zoom:80%;" /> 

```java
@Override
    public Result getCompanyInfo() {

        // 检验参数当前用户是否登录
        UserInfo userInfo = CurrentUserHolder.get();
        if (userInfo == null) {
            return Result.errorMessage("用户未登录");
        }

        Long companyId = userInfo.getCompanyId();

        // 根据企业id查询企业信息回显
        SysCompany sysCompany = sysCompanyMapper.selectById(companyId);
        if (sysCompany == null || sysCompany.getAuditStatus() != 1) {
            return Result.errorMessage("该企业不存在");
        }

        return Result.success(sysCompany);
    }
```



#### 1.2企业Logo上传

![image-20220703172435309](面试项目准备.assets/image-20220703172435309.png) 

请求路径为：http://localhost:10010/sys/company/uploadOSS

![image-20220703172528053](面试项目准备.assets/image-20220703172528053.png) 

```java
// 我的代码
@Override
    public Result uploadLogo(MultipartFile multipartFile) {
        // 检验参数当前用户是否登录
        UserInfo userInfo = CurrentUserHolder.get();
        if (userInfo == null) {
            return Result.errorMessage("用户未登录");
        }

        if (multipartFile == null) {
            return Result.errorMessage("图片不存在");
        }

        // 判断图片格式是否正确
        String contentType = multipartFile.getContentType();
        if (!NcConstant.ALLOWED_IMG_TYPES.contains(contentType)) {

            return Result.errorMessage("图片格式不正确");
        }

        // 拼接图片名
        String filename = multipartFile.getOriginalFilename();
        String[] split = filename.split("\\.");
        String s = split[split.length - 1];
        String key = UUID.randomUUID().toString() + "." + s;

        // 图片上传阿里云OSS
        try {
            ossClient.putObject(ossProperties.getBucketName(), key, multipartFile.getInputStream());
        } catch (IOException e) {
            e.printStackTrace();
        }

        log.info("图片logo上传OSS成功");


        // 获取图片访问链接
        // 设置url过期时间为1小时
        Date expiration = new Date(System.currentTimeMillis() + 3600 * 1000 * 24 * 365);

        GeneratePresignedUrlRequest generatePresignedUrlRequest = new GeneratePresignedUrlRequest(ossProperties.getBucketName(), key);
        generatePresignedUrlRequest.setExpiration(expiration);
        URL url = ossClient.generatePresignedUrl(generatePresignedUrlRequest);

        return Result.success("图片上传成功", url);
    }
```

```java
// 老师的代码
@Override
    public String uploadOSS(MultipartFile file) {

        //TODO 判断用户登录情况

        //1. 检验文件合法性
        //1.1 检查文件内容是否为空
        if(file==null || file.isEmpty()){
            throw new NcException(ResponseEnum.FILE_NOT_FOUND);
        }

        //1.2 检查文件类型是否符合要求
        String type = file.getContentType();
        if(!NcConstant.ALLOWED_IMG_TYPES.contains(type)){
            throw new NcException(ResponseEnum.INVALID_FILE_TYPE);
        }

        //1.3 检查文件大小是否超过限制
        long size = file.getSize();
        if(size> NcConstant.maxFileSize){
            throw new NcException(ResponseEnum.FILE_SIZE_EXCEED_MAX_LIMIT);
        }

        //2.生成唯一文件名
        String dateStr = DateFormatUtils.format(new Date(), "yyyyMMddHHmmssSSS");
        String fileName = dateStr +file.getOriginalFilename();

        //3.执行上传
        try {
            /**
             * 参数1：  桶名
             * 参数2：  文件名
             * 参数3： 上传文件的输入流
             */
            ossClient.putObject(ossProperties.getBucketName(),fileName,file.getInputStream());
        } catch (IOException e) {
            e.printStackTrace();
        }


        //4.响应logo的url访问地址
        String url = String.format(ossProperties.getHost(),ossProperties.getBucketName()) +  fileName;

        return url;
    }
```



#### 1.3修改企业基本信息

![image-20220703172852440](面试项目准备.assets/image-20220703172852440.png) 

请求路径有两个，一个是更新操作，一个是回显操作

![image-20220703172956397](面试项目准备.assets/image-20220703172956397.png) 

```java
@Override
    public Result updateCompanyInfo(SysCompanyInfoDTO dto) {

        // 检验参数当前用户是否登录
        UserInfo userInfo = CurrentUserHolder.get();
        if (userInfo == null) {
            return Result.errorMessage("用户未登录");
        }

        // 参数校验
        if (dto == null || dto.getName().isEmpty() || dto.getLogo().isEmpty()) {
            return Result.errorMessage("参数错误");
        }

        Long companyId = userInfo.getCompanyId();


        SysCompany sysCompany = this.getOne(Wrappers.<SysCompany>lambdaQuery().eq(SysCompany::getId, companyId));
        if (sysCompany == null) {
            return Result.errorMessage("不存在该企业");
        }

        // TODO 删除阿里云原来存储的图片(垃圾图片)



        sysCompany.setName(dto.getName());
        sysCompany.setLogo(dto.getLogo());

        boolean flag = this.updateById(sysCompany);
        if (flag) {
            return Result.success("更新成功");
        } else {
            return Result.errorMessage("更新失败");
        }
    }
```



### 2.企业管理员更新

![image-20220703180951916](面试项目准备.assets/image-20220703180951916.png) 

<img src="面试项目准备.assets/image-20210128182458713.png" alt="image-20210128182458713" style="zoom: 67%;" /> 

#### 2.1短信平台对接测试

#### 2.2发送短信验证码

请求路径：http://localhost:10010/sys/sms/code?channel=2&mobile=17792648116&type=3

```java
// 我的代码
@Override
    public Result sendSms(String mobile, String type) {


        if (!PhoneNumCheckUtils.isChinaPhoneLegal(mobile)) {
            return Result.errorMessage("手机号码格式不正确");
        }


        String code = "996521";
        smsUtils.sendSms(mobile, code);
        log.info("发送的验证码为" + code);

        // 将验证码存入redis 过期时间5分钟
        String redisKey  = getPrefix(type) +  mobile;

        // redisTemplate.opsForValue().set(redisKey, code, 5, TimeUnit.MINUTES);

        // //4.将短信验证码存入redis，过期时间5分钟
        redisTemplate.boundValueOps(redisKey).set(code,5, TimeUnit.MINUTES);
        log.info("验证码已发送到redis" + code);


        return Result.successMessage("短信发送成功");
    }
```

```java
// 老师代码
@Override
    public void sendSmsCode(String mobile, String type) {

        //1.判断参数合法性
        //1.1 判断参数是否为空
        if(StrUtil.isEmpty(mobile) || StrUtil.isEmpty(type)){
            throw new NcException(ResponseEnum.INVALID_PARAM_ERROR);
        }

        //1.2 判断手机号格式是否正确
        if(!PhoneNumCheckUtils.isPhoneLegal(mobile)){
            throw new NcException(ResponseEnum.INVALID_PHONE_NUMBER);
        }

        //2.判断类型，是否是注册场景
        //2.1 如果是注册，那么手机号在表中不能存在
        if(type.equals(SMSConstant.SMS_TYPE_REGISTER)){
            Boolean flag = sysUserService.checkMobileExists(mobile);
            if(flag){
                throw new NcException(ResponseEnum.USER_MOBILE_EXISTS);
            }
        } else {
            //2.1 如果不是注册，那么手机要在表中一定要存在
            Boolean flag = sysUserService.checkMobileExists(mobile);
            if(!flag){
                throw new NcException(ResponseEnum.USER_NOT_REGISTER);
            }
        }

        //3.调用阿里云发送短信
        String code = RandomUtil.randomNumbers(6);
        log.info("验证码：{}" , code);
//        boolean result = smsUtils.sendSms(mobile, code);
//        if(!result){
//            throw new NcException(ResponseEnum.SEND_MESSAGE_ERROR);
//        }

        //4.将短信验证码存入redis，过期时间5分钟
        String redisKey  = getPrefix(type) +  mobile;
        redisTemplate.boundValueOps(redisKey).set(code,5, TimeUnit.MINUTES);

        log.info("成功发送验证码 , {}->{} " , mobile, code);
    }
/**
     * 根据类型获取redis的key名称
     */
    private String getPrefix(String type){
        switch (type) {
            case SMSConstant.SMS_TYPE_LOGIN:
                return SMSConstant.SMS_LOGIN_KEY_PREFIX;
            case SMSConstant.SMS_TYPE_REGISTER:
                return SMSConstant.SMS_REGISTER_KEY_PREFIX;
            case SMSConstant.SMS_TYPE_CHANGE_MANAGER:
                return SMSConstant.SMS_CHANGE_MANAGER_KEY_PREFIX;
            case SMSConstant.SMS_TYPE_RESET_PASSWORD:
                return SMSConstant.SMS_RESET_KEY_PREFIX;
            default:
                return null;
        }
    }
```



#### 2.3校验验证码

```java
@Override
    public Boolean verifyCode(String checkcode, String mobile, String type) {


        //1.获取redisKey
        String redisKey  = getPrefix(type) +  mobile;

        //2.根据redisKey从redis查询code
        String code = (String)redisTemplate.boundValueOps(redisKey).get();


        // String code = (String) redisTemplate.opsForValue().get("" + mobile);


        if (code == null) {
            return false;
        }

        log.info("此时redis中的验证码为" + code);


        if (checkcode.equals(code)) {
            redisTemplate.delete("" + mobile);
            log.info("验证成功");
            return true;

        } else {
            log.info("验证失败");

            return false;
        }

    }
```



#### 2.4查询企业当前主管理员

![image-20220703181327082](面试项目准备.assets/image-20220703181327082.png) 

回显请求路径：http://localhost:10010/sys/company/getCurrentAdmin

```java
@Override
    public Result getCurrentAdmin() {

        // 检验参数当前用户是否登录
        UserInfo userInfo = CurrentUserHolder.get();
        if (userInfo == null) {
            return Result.errorMessage("用户未登录");
        }

        // 获取当前用户所在的公司id
        Long companyId = userInfo.getCompanyId();

        // 根据company_id三表查询当前公司系统管理员的user信息，非空判断
        SysCompanyUser adminSysByCompanyId = sysCompanyUserMapper.getAdminSysByCompanyId(companyId);

        if (adminSysByCompanyId == null) {
            return Result.errorMessage("该企业未设置管理员");
        }

        // 返回CompanyUser对象
        return Result.success(adminSysByCompanyId);
    }
```



#### 2.5查询企业员工列表

如果验证码验证正确，则进入下一步

![image-20220703182231004](面试项目准备.assets/image-20220703182231004.png) 

请求路径：http://localhost:10010/sys/organization/members/simple

```java
@Override
    public Result getAllUser() {

        UserInfo userInfo = CurrentUserHolder.get();

        Long companyId = userInfo.getCompanyId();

        List<SysCompanyUser> list = this.list(Wrappers.<SysCompanyUser>lambdaQuery().eq(SysCompanyUser::getCompanyId, companyId).eq(SysCompanyUser::getEnable, 1));




        return Result.success(list);
    }
```



#### 2.6更换主管理员

验证新管理员后进入下一步，请求路径为：http://localhost:10010/sys/company/config/admin

![image-20220703182436467](面试项目准备.assets/image-20220703182436467.png) 

```java
@Override
    public Result updateAdmin(SysCompanyAdminDTO dto) {

        // 校验参数合法性
        if (dto == null || StrUtil.isEmpty(dto.getCode()) || dto.getUserId() == null) {

            return Result.errorMessage("参数错误");
        }



        Long companyId = CurrentUserHolder.get().getCompanyId();
        long companyUserId = CurrentUserHolder.get().getCompanyUserId();
        Long companyUserIdNew = dto.getUserId(); //新的管理员公司用户ID

        //2.根据新用户ID查询是否存在
        SysCompanyUser sysCompanyUser = sysCompanyUserService.getById(companyUserIdNew);
        if(sysCompanyUser==null){
            throw new NcException(ResponseEnum.USER_NOT_FOUND);
        }

        //3.判断验证码是否正确
        String redisKey  = SMSConstant.SMS_CHANGE_MANAGER_KEY_PREFIX + sysCompanyUser.getMobile();
        String redisCode = (String)redisTemplate.boundValueOps(redisKey).get();
        if(!redisCode.equals(dto.getCode())){
            throw new NcException(ResponseEnum.INVALID_VERIFY_CODE);
        }

        //4.根据公司ID查询角色
        LambdaQueryWrapper<SysRole> lambdaQueryWrapperForRole = new LambdaQueryWrapper();
        lambdaQueryWrapperForRole.eq(SysRole::getCompanyId, companyId);
        lambdaQueryWrapperForRole.eq(SysRole::getRoleName, "ROLE_ADMIN_SYS");
        SysRole sysRole = sysRoleMapper.selectOne(lambdaQueryWrapperForRole);
        Long roleId = sysRole.getId();


        //5.删除旧的管理员与公司的关系
        LambdaQueryWrapper<SysCompanyUserRole> lambdaQueryWrapperForDelete = new LambdaQueryWrapper<>();
        lambdaQueryWrapperForDelete.eq(SysCompanyUserRole::getCompanyId, companyId);
        lambdaQueryWrapperForDelete.eq(SysCompanyUserRole::getCompanyUserId, companyUserId);
        lambdaQueryWrapperForDelete.eq(SysCompanyUserRole::getRoleId, roleId);
        sysCompanyUserRoleMapper.delete(lambdaQueryWrapperForDelete);


        //6.添加新管理员与公司的关系
        SysCompanyUserRole sysCompanyUserRole = new SysCompanyUserRole();
        sysCompanyUserRole.setCompanyId(companyId);
        sysCompanyUserRole.setRoleId(roleId);
        sysCompanyUserRole.setCompanyUserId(dto.getUserId());
        sysCompanyUserRoleMapper.insert(sysCompanyUserRole);

        //7.删除redis
        redisTemplate.delete(redisKey);

        return Result.success();

    }
```



### 3.考勤后台管理

#### 3.1考勤组列表接口

![image-20220707152241166](面试项目准备.assets/image-20220707152241166.png) 

![image-20220707152342876](面试项目准备.assets/image-20220707152342876.png) 



**远程feign接口调用问题分析与解决**

当我们在进行接口调用测试时, 服务端会报出一个错误, Feign远程调用时, 没有权限 ; 

![image-20210317094805860](面试项目准备.assets/image-20210317094805860.png) 



而我们在调用时, 请求头中的 Authorization 是传递了的, 为什么Feign远程调用时, 报出没有权限这样的错误呢 ? 

<img src="D:/myLearningFile/黑马程序员北京金燕龙黑马JavaEE就业384期（20211106面授）——资料/（五）微服务项目/九点钟/九点钟实战/学生用资料/第二阶段-团队实战（5天）/第二阶段-团队实战（5天）/day04-day08/day04-day08-团队实战任务说明书/img/image-20210317095416349.png" alt="image-20210317095416349" style="zoom:80%;" /> 

原因: Feign在进行远程调用时, 默认是没有将请求头继续往下传递的, 而系统微服务接入认证之后, 必须携带JWT令牌才可以访问, 没有携带令牌就访问系统服务, 就会出现401 , 未认证 错误 。



解决方案：

使用Feign的拦截器来解决， 拦截所有的feign的远程调用， 在进行远程调用时， 拦截住请求， 并让请求头Authorization 继续往下传递 

```java
@Component
public class FeignInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if(requestAttributes != null){
            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
            String authorization = request.getHeader("Authorization");
            template.header("Authorization", authorization);

        }
    }
}
```



**分页查询考勤组分组列表**

实现思路：

1.根据公司ID查询考勤分组数量

2.如果数量等于0，则初始化考勤分组，设置所有部门使用默认分组

  2.1查询所有顶级部门id(Feign接口)

```java
List<Long> deptIdList = organizationFeign.findTopDeptIdList();
```

![image-20220707163718570](面试项目准备.assets/image-20220707163718570.png) 

![image-20220707163744791](面试项目准备.assets/image-20220707163744791.png) 

![image-20220707163823382](面试项目准备.assets/image-20220707163823382.png) 

  2.2遍历部门id，设置所有顶级部门都使用默认考勤分组

```java
for (Long deptId : deptIdList) {
                //构建考勤分组关联数据
                AttendGroupPart attendGroupPart = new AttendGroupPart();
                attendGroupPart.setAttendGroupId(attendGroup.getId());//考勤分组ID
                attendGroupPart.setAttendType(AttendEnums.ATTEND_TYPE_YES.value());//确认参加
                attendGroupPart.setObjectType(AttendEnums.ATTEND_OBJECT_TYPE_DEP.value());//类型：部门
                attendGroupPart.setObjectId(deptId);//部门ID
                attendGroupPartMapper.insert(attendGroupPart);
            }
```

3.分页查询考勤分组列表

4.遍历每个分组，设置每个考勤分组对应的员工数量

```java
for (AttendGroupDTO attendGroupDTO : attendGroupDTOList) {
            Long attendGroupId = attendGroupDTO.getId();

            //通过考勤分组ID，查询对应的部门ID列表
            List<AttendGroupPart> attendGroupPartsDept = attendGroupPartMapper.selectList(Wrappers.<AttendGroupPart>lambdaQuery()
                    .eq(AttendGroupPart::getAttendGroupId, attendGroupId)
                    .eq(AttendGroupPart::getAttendType, AttendEnums.ATTEND_TYPE_YES.value())
                    .eq(AttendGroupPart::getObjectType, AttendEnums.ATTEND_OBJECT_TYPE_DEP.value())
                    .select(AttendGroupPart::getObjectId));
            List<Long> deptIdList = attendGroupPartsDept.stream().map(AttendGroupPart::getObjectId).collect(Collectors.toList());

            Integer deptUserCount = 0;
            if(CollectionUtil.isNotEmpty(deptIdList)){
                deptUserCount =  organizationFeign.findDeptUserCount(deptIdList);;
            }

            //通过考勤分组ID，查询对应的员工ID
            List<AttendGroupPart> attendGroupPartsUser = attendGroupPartMapper.selectList(Wrappers.<AttendGroupPart>lambdaQuery()
                    .eq(AttendGroupPart::getAttendGroupId, attendGroupId)
                    .eq(AttendGroupPart::getAttendType, AttendEnums.ATTEND_TYPE_YES.value())
                    .eq(AttendGroupPart::getObjectType, AttendEnums.ATTEND_OBJECT_TYPE_USER.value()).select(AttendGroupPart::getObjectId));
            List<Long> userIdList = attendGroupPartsUser.stream().map(AttendGroupPart::getObjectId).collect(Collectors.toList());

            //考勤分组内，所有员工数量=考勤分组关联表中关联的部门下的员工数 +  考勤分组关联表中直接关联的员工数

            int totalNum = deptUserCount + userIdList.size();
            attendGroupDTO.setMemberNum(totalNum);
        }
```



#### 3.2新增考勤组

要完成 新增考勤组 的需求 , 需要开发两个接口: 

A. 根据部门ID, 获取部门列表及员工列表接口

![image-20220707182538853](面试项目准备.assets/image-20220707182538853.png) 

![image-20220707182705521](面试项目准备.assets/image-20220707182705521.png) 

请求路径：http://localhost:10010/sys/organization/simple?id=0&includeMember=0

![image-20220707182818765](面试项目准备.assets/image-20220707182818765.png) 

```java
@Override
    public List<DepartmentOrUserSimpleDTO> findDeptOrUserList(Long deptId) {
        if(deptId==null){
            throw new NcException(ResponseEnum.INVALID_PARAM_ERROR);
        }

        List<DepartmentOrUserSimpleDTO> resultList = new ArrayList<>();

        Long companyId = CurrentUserHolder.get().getCompanyId();

        //根据公司ID和父部门ID查询子部门列表
        List<SysDepartment> departmentList = this.list(Wrappers.<SysDepartment>lambdaQuery()
                .eq(SysDepartment::getCompanyId, companyId)
                .eq(SysDepartment::getParentId, deptId));

        if(CollectionUtil.isNotEmpty(departmentList)){
            departmentList.forEach(x->{
                DepartmentOrUserSimpleDTO dto = new DepartmentOrUserSimpleDTO();
                dto.setId(x.getId()); //部门ID
                dto.setName(x.getName());//部门名称
                dto.setType(AttendEnums.ATTEND_OBJECT_TYPE_DEP.value());//类型：部门

                resultList.add(dto);
            });
        } else {//如果没有查到部门列表，说明到了最后一级部门，可以查询员工列表
            List<SysCompanyUser> sysCompanyUserList = sysCompanyUserService.list(Wrappers.<SysCompanyUser>lambdaQuery()
                    .eq(SysCompanyUser::getCompanyId, companyId)
                    .eq(SysCompanyUser::getDepartmentId, deptId)
            );

            if(CollectionUtil.isNotEmpty(sysCompanyUserList)){
                sysCompanyUserList.forEach(x->{
                    DepartmentOrUserSimpleDTO dto = new DepartmentOrUserSimpleDTO();
                    dto.setId(x.getId()); //员工ID
                    dto.setName(x.getUserName());//员工姓名
                    dto.setType(AttendEnums.ATTEND_OBJECT_TYPE_USER.value());//类型：员工
                    resultList.add(dto);
                });
            }

        }

        return resultList;
    }
```

B. 新增考勤组接口

![image-20220707191739087](面试项目准备.assets/image-20220707191739087.png) 

```java
@Override
    public Result addAttendGroup(AttendGroupDTO dto) {
        //1.判断参数
        if(dto==null){
            throw new NcException(ResponseEnum.INVALID_PARAM_ERROR);
        }

        //2.拷贝dto
        AttendGroup attendGroup = BeanHelper.copyProperties(dto, AttendGroup.class);

        //3.设置特殊属性值
        //3.1 设置公司ID和员工ID
        attendGroup.setCompanyId(CurrentUserHolder.get().getCompanyId());
        attendGroup.setCreateUserId(CurrentUserHolder.get().getCompanyUserId());
        attendGroup.setUpdateUserId(CurrentUserHolder.get().getCompanyUserId());

        //3.2 设置日期属性值
        //3.2.1 工作日，DTO里日期的列表类型转为逗号拼接的字符串
        if(CollectionUtil.isNotEmpty(dto.getWorkdays())){
            attendGroup.setWorkdays(StrUtil.join(",",dto.getWorkdays().toArray()));
        }

        //3.2.2 特殊日期
        if(CollectionUtil.isNotEmpty(dto.getExtraConfig())){

            //必须打卡的日期
            List<String> necessaryTimeList = new ArrayList<>();

            //非必须打卡的日期
            List<String> notNecessaryTimeList = new ArrayList<>();

            dto.getExtraConfig().forEach(x->{
                String timeStamp = x.getSetDate();
                String dateStr = DateUtil.format(new Date(Long.valueOf(timeStamp)), "yyyy-MM-dd");
                //必须打卡
                if(x.getRequiredAttend()==1){
                    necessaryTimeList.add(dateStr);
                } else { //非必须打卡
                    notNecessaryTimeList.add(dateStr);
                }
            });

            //设置必须打卡的日期，将列表类型转为逗号拼接的字符串
            attendGroup.setNecessaryTimeList(StrUtil.join(",",necessaryTimeList.toArray()));
            //设置非必须打卡的日期，将列表类型转为逗号拼接的字符串
            attendGroup.setUnnecessaryTimeList(StrUtil.join(",",notNecessaryTimeList.toArray()));
        }

        //4.保存考勤分组
        this.save(attendGroup);

        //5.保存考勤分组关联信息（参与考勤的和非参与考勤的）
        saveAttendGroupPart(dto,attendGroup);
        return null;
    }



    private void saveAttendGroupPart(AttendGroupDTO dto, AttendGroup attendGroup) {
        //1.处理参与考勤的信息
        List<AttendGroupPartDTO> groupPartDTOListMust = dto.getParticipates();
        if(CollectionUtil.isNotEmpty(groupPartDTOListMust)){
            groupPartDTOListMust.forEach(x->{
                //1.1 根据对象ID和对象类型 删除旧的关系数据
                attendGroupPartMapper.delete(Wrappers.<AttendGroupPart>lambdaQuery()
                        .eq(AttendGroupPart::getObjectId, x.getObjectId())
                        .eq(AttendGroupPart::getObjectType, x.getObjectType()));

                //1.2 保存新的关系数据
                AttendGroupPart attendGroupPart = new AttendGroupPart();
                attendGroupPart.setAttendGroupId(attendGroup.getId()); //考勤分组ID
                attendGroupPart.setObjectId(x.getObjectId()); //对象ID
                attendGroupPart.setObjectType(x.getObjectType());//对象类型
                attendGroupPart.setAttendType(AttendEnums.ATTEND_TYPE_YES.value());//参加
                attendGroupPartMapper.insert(attendGroupPart);
            });
        }

        //2.处理非参与考勤的信息
        List<AttendGroupPartDTO> groupPartDTOListNot = dto.getNotParticipates();
        if(CollectionUtil.isNotEmpty(groupPartDTOListNot)){
            groupPartDTOListNot.forEach(x->{
                //1.1 根据对象ID和对象类型 删除旧的关系数据
                attendGroupPartMapper.delete(Wrappers.<AttendGroupPart>lambdaQuery()
                        .eq(AttendGroupPart::getObjectId, x.getObjectId())
                        .eq(AttendGroupPart::getObjectType, x.getObjectType()));

                //1.2 保存新的关系数据
                AttendGroupPart attendGroupPart = new AttendGroupPart();
                attendGroupPart.setAttendGroupId(attendGroup.getId()); //考勤分组ID
                attendGroupPart.setObjectId(x.getObjectId()); //对象ID
                attendGroupPart.setObjectType(x.getObjectType());//对象类型
                attendGroupPart.setAttendType(AttendEnums.ATTEND_TYPE_NO.value());//不参加
                attendGroupPartMapper.insert(attendGroupPart);
            });
        }
    }
```



### 4.移动端打卡

在移动端的 "考勤打卡" 模块中, 会包含两个接口 : 

1). 查询当前用户关联的考勤组信息

2). 打卡接口

![image-20220707192431084](面试项目准备.assets/image-20220707192431084.png) 

#### 4.1获取考勤组

![image-20220708141653308](面试项目准备.assets/image-20220708141653308.png) 

![image-20220708155129340](面试项目准备.assets/image-20220708155129340.png) 

![image-20220708141713933](面试项目准备.assets/image-20220708141713933.png) 

1.根据当前员工ID和类型查询考勤关联数据

```java
//1.根据当前员工ID和类型查询考勤关联数据
        Long companyUserId = CurrentUserHolder.get().getCompanyUserId();
        AttendGroupPart attendGroupPart = attendGroupPartMapper.selectOne(Wrappers.<AttendGroupPart>lambdaQuery()
                .eq(AttendGroupPart::getObjectId, companyUserId) //员工ID
                .eq(AttendGroupPart::getObjectType, AttendEnums.ATTEND_OBJECT_TYPE_USER.value())//类型：员工
                .eq(AttendGroupPart::getAttendType, AttendEnums.ATTEND_TYPE_YES.value()) //参加考勤
        );
```

2.如果查不到，则获取所有上级部门ID，根据任意部门ID和类型获取考勤关联数据

![image-20220708161114852](面试项目准备.assets/image-20220708161114852.png) 

![image-20220708161200355](面试项目准备.assets/image-20220708161200355.png) 

![image-20220708161214907](面试项目准备.assets/image-20220708161214907.png) 

```java
@Override
    public List<Long> findSuperDetpIdList(Long companyUserId) {
        //1.判断参数
        if(companyUserId==null){
            throw new NcException(ResponseEnum.INVALID_PARAM_ERROR);
        }

        //2.根据公司ID和员工ID查询员工信息
        SysCompanyUser sysCompanyUser = sysCompanyUserService.getById(companyUserId);
        if(sysCompanyUser==null){
            throw new NcException(ResponseEnum.DATA_NOT_EXISTS);
        }

        //3.根据员工的部门ID查询部门
        long deptId = sysCompanyUser.getDepartmentId();
        List<Long> departIdList = new ArrayList<>();
        departIdList.add(deptId);

        while(true){
            SysDepartment sysDepartment = this.getById(deptId);
            Long parentId = sysDepartment.getParentId();
            if(parentId!=null && parentId!=0){
                departIdList.add(parentId);
                deptId = parentId;
            } else {
                break;
            }
        }
        //4.得到部门的上级ID，轮询获取所有上级部门ID
        return departIdList;
    }
```



3.根据考勤分组ID查询考勤分组

```java
//3.根据考勤分组ID查询考勤分组
        if(attendGroupPart!=null){
            AttendGroup attendGroup = this.getById(attendGroupPart.getAttendGroupId());


            //4.复制数据给dto
            AttendGroupDTO attendGroupDTO = BeanHelper.copyProperties(attendGroup, AttendGroupDTO.class);

            //5.处理工作日时间
            String workdays = attendGroup.getWorkdays();

            //6.将工作时间从逗号拼接的字符串转为DTO需要的列表
            if(StrUtil.isNotBlank(workdays)){
                attendGroupDTO.setWorkdays(Arrays.asList(workdays.split(",")));
            }

            return attendGroupDTO;
        }
```



#### 4.2移动端打卡

实现步骤参考：

+ 1. 判断参数

+ 2. 封装考勤打卡对象并设置特殊属性值

+ 3. 获取考勤分组

+ 4. 判断打卡是否合法（是否在有效范围内、是否工作日、是否有效时间打卡）

+ 5. 设置打卡结果类型

+ 6. 保存打卡记录

  ![image-20220709101622798](面试项目准备.assets/image-20220709101622798.png) 

  ```java
  @Autowired
      private AttendGroupService attendGroupService;
  
      /**
       * 实现思路：
       * 1. 判断参数
       * 2. 封装考勤打卡对象并设置特殊属性值
       * 3. 获取考勤分组
       * 4. 判断打卡是否合法（是否在有效范围内、是否工作日、是否有效时间打卡）
       * 5. 设置打卡结果类型
       * 6. 保证打卡记录
       * @param dto
       */
      @Override
      public void attendPunch(AttendPunchDTO dto) {
          //1. 判断参数
          if(dto==null){
              throw new NcException(ResponseEnum.INVALID_PARAM_ERROR);
          }
  
          Long companyUserId = CurrentUserHolder.get().getCompanyUserId();
          Long companyId = CurrentUserHolder.get().getCompanyId();
  
          //2.封装考勤打卡对象并设置特殊属性值
          //2.1 拷贝dto给打卡对象
          AttendPunch attendPunch = BeanHelper.copyProperties(dto, AttendPunch.class);
          //2.2 设置特殊属性值
          attendPunch.setCreateTime(new Date());//创建时间
          attendPunch.setPunchTime(new Date());//打卡时间
          attendPunch.setPunchDateStr(DateTimeUtil.dateToStr(new Date(), DateTimeUtil.TIME_FORMAT_2));//打卡时间，格式yyyy-MM-dd
          attendPunch.setCompanyId(companyId); //公司ID
          attendPunch.setCompanyUserId(companyUserId); //员工ID
          attendPunch.setPunchOnOffWork(DateTimeUtil.noonType(new Date())+1); //设置是上午打卡还是下午打卡
          attendPunch.setLat(BigDecimal.valueOf(dto.getLat()));//维度
          attendPunch.setLng(BigDecimal.valueOf(dto.getLng()));//精度
  
          //3.查询考勤分组
          AttendGroupDTO attendGroup = attendGroupService.findCurrentAttendGroup();
          if(attendGroup==null){
              throw new NcException(ResponseEnum.DATA_NOT_EXISTS);
          }
  
  
          //4. 判断打卡是否合法（是否在有效范围内、是否工作日、是否有效时间打卡）
          //4.1 检查打卡地点是否在有效范围类
          boolean checkAreaResult = checkArea(dto, attendGroup);
          attendPunch.setAreaValid(checkAreaResult);
          if(!checkAreaResult){
              throw new NcException(ResponseEnum.PUNCH_INVALID_AREA);
          }
  
          //4.2 检查是否在工作日打卡
          boolean checkDayResult = checkDay(attendGroup);
          if(!checkDayResult){
              throw new NcException(ResponseEnum.PUNCH_INVALID_DAY);
          }
  
          //4.3 检查上下午打卡是否有效
          checkMorningAndAfternoon(attendPunch, attendGroup);
  
          //5. 如果是有效打卡，则设置打卡结果类型（上下午打卡是否正常）
          if(attendPunch.getEffectiveValid()){
              setAttendType(attendPunch, attendGroup);
          }
  
          //6. 保存打卡记录
          this.save(attendPunch);
  
      }
  
      private void setAttendType(AttendPunch attendPunch, AttendGroupDTO attendGroup) {
          //1.获取允许迟到分钟数和旷工迟到分钟数
          Integer allowLateMinutes = attendGroup.getAllowLateMinutes();//考勤分组设置的：允许迟到分钟数
          Integer lateMinutes = attendGroup.getLateMinutes();//考勤分组设置的：旷工迟到分钟数
          String startWorkTime = attendGroup.getStartWorkTime();//考勤分组设置的：上班开始时间
          String offWorkTime = attendGroup.getOffWorkTime();//考勤分组设置的：下班结束时间
  
  
          String punchDateStr = DateTimeUtil.dateToStr(attendPunch.getPunchTime(), DateTimeUtil.TIME_FORMAT_1);//员工实际打卡时间，格式：HH:mm:ss 时分秒
  
          //2.判断上午迟到和旷工情况
          if(attendPunch.getPunchOnOffWork()== AttendEnums.NOON_TYPE_MORNING.value()){
              attendPunch.setMorningPunchType(AttendEnums.PUNCH_NORMAL.value());//默认情况下是正常打卡
  
              int allowLateResult = DateTimeUtil.compareTime(punchDateStr, startWorkTime, allowLateMinutes);
              if(allowLateResult==1){ //如果员工实际打卡时间> 工作开始时间+允许迟到的时间，则为迟到
                  attendPunch.setMorningPunchType(AttendEnums.PUNCH_TYPE_LATE.value());
              }
  
              int lateResult = DateTimeUtil.compareTime(punchDateStr, startWorkTime, lateMinutes);
              if(lateResult==1){//如果员工实际打卡时间> 工作开始时间+旷工迟到的时间，则为旷工
                  attendPunch.setMorningPunchType(AttendEnums.PUNCH_TYPE_STAYALAY.value());
              }
          } else {  //3.判断下午迟到和旷工情况
              attendPunch.setAfternoonPunchType(AttendEnums.PUNCH_NORMAL.value());//默认情况下是正常打卡
  
              int allowLateResult = DateTimeUtil.compareTime(offWorkTime, punchDateStr, allowLateMinutes);
              if(allowLateResult==1){ //如果工作结束时间 > 员工实际打卡时间+允许迟到的时间，则为早退
                  attendPunch.setAfternoonPunchType(AttendEnums.PUNCH_TYPE_EARLY.value());
              }
  
              int lateResult = DateTimeUtil.compareTime(offWorkTime, punchDateStr, lateMinutes);
              if(lateResult==1){//如果工作结束时间 > 员工实际打卡时间+旷工迟到的时间，则为旷工
                  attendPunch.setAfternoonPunchType(AttendEnums.PUNCH_TYPE_STAYALAY.value());
              }
          }
  
      }
  
      private void checkMorningAndAfternoon(AttendPunch attendPunch, AttendGroupDTO attendGroup) {
          //1.查询是否已经有过打卡记录
          int count = this.count(Wrappers.<AttendPunch>lambdaQuery()
                  .eq(AttendPunch::getCompanyId, attendPunch.getCompanyId())
                  .eq(AttendPunch::getCompanyUserId, attendPunch.getCompanyUserId())
                  .eq(AttendPunch::getPunchOnOffWork, attendPunch.getPunchOnOffWork())
                  .eq(AttendPunch::getPunchDateStr, attendPunch.getPunchDateStr())
          );
  
  
          //2.如果从未打过卡，则打卡有效
          if(count==0){
              attendPunch.setEffectiveValid(true);
          } else {
              //3.如果打过卡，则判断上下午打卡具体情况
  
              //3.1如果上午打过卡，在打卡则无效
              Integer punchOnOffWork = attendPunch.getPunchOnOffWork();
              if(punchOnOffWork== AttendEnums.NOON_TYPE_MORNING.value()){ //如果是上午打卡
                  attendPunch.setEffectiveValid(false);
              } else {
                  //3.2.如果是下午打过卡，再打卡有效，以最后一次为主，之前的下午打卡无效
                  attendPunch.setEffectiveValid(true);
  
                  this.update(Wrappers.<AttendPunch>lambdaUpdate()
                          .eq(AttendPunch::getCompanyId, attendPunch.getCompanyId())
                          .eq(AttendPunch::getCompanyUserId, attendPunch.getCompanyUserId())
                          .eq(AttendPunch::getPunchOnOffWork, attendPunch.getPunchOnOffWork())
                          .eq(AttendPunch::getPunchDateStr, attendPunch.getPunchDateStr())
                          .set(AttendPunch::getEffectiveValid, false));
              }
          }
      }
  
      private boolean checkDay(AttendGroupDTO dto) {
          int dayNum = DateUtil.thisDayOfWeek(); //获取今天是一周的第几天，1-周日 2-周一 3-周二 4-周三 5-周四 6-周五 7-周六
  
          List<String> workdaysList = dto.getWorkdays();//考勤组的工作日 [1,1,1,1,1,0,0]
  
          //获取考勤工作日的索引
  
          int index = 0;
          if(dayNum==1){
              index = 6;
          } else {
              index = dayNum - 2;
          }
  
          //如果根据索引从列表中获取的值是1，则说明是工作日
          return "1".equals(workdaysList.get(index));
      }
  
  
      //检查打卡地点是否在有效范围类
      private boolean checkArea(AttendPunchDTO dto, AttendGroupDTO attendGroup) {
          //查询打卡地点和考勤地点的距离范围
          Integer meter = DistanceUtil.getDistanceMeter(dto.getLat(), dto.getLng(), attendGroup.getLat(), attendGroup.getLng());
          log.info("打卡距离：{}", meter);
          //如果在考勤组允许的距离范围内则为有效打卡
          return meter < attendGroup.getAddressRange();
      }
  
  
  
      private String handlePunchList(List<AttendPunch> punchList) {
          String amStatus = "缺卡";
          String pmStatus = "缺卡";
  
          for (AttendPunch attendPunch : punchList) {
              if(attendPunch.getPunchOnOffWork().equals(AttendEnums.NOON_TYPE_MORNING.value())){
                  amStatus = getDesc(attendPunch.getMorningPunchType());
              }
  
              if(attendPunch.getPunchOnOffWork().equals(AttendEnums.NOON_TYPE_AFTERNOON.value())){
                  pmStatus = getDesc(attendPunch.getAfternoonPunchType());
              }
          }
  
          //每天打卡结果状态格式：  上午状态/午状态
          return amStatus + "/" + pmStatus;
      }
  
      private String getDesc(Integer type) {
          switch (type){
              case 1:
                  return AttendEnums.PUNCH_NORMAL.toString();
              case 2:
                  return AttendEnums.PUNCH_MAKEUP.toString();
              case 3:
                  return AttendEnums.PUNCH_TYPE_EARLY.toString();
              case 4:
                  return AttendEnums.PUNCH_TYPE_STAYALAY.toString();
              default:
                  return AttendEnums.PUNCH_TYPE_NOT_WORK_DAY.toString();
          }
      }
  ```

  

#### 4.3查询打卡数据接口

![image-20220709120850357](面试项目准备.assets/image-20220709120850357.png) 

```java
 @Override
    public AttendPunchUserWholeDayDTO findPunchRecord() {

        Long companyId = CurrentUserHolder.get().getCompanyId();
        Long companyUserId = CurrentUserHolder.get().getCompanyUserId();

        //查询上午打卡数据
        AttendPunch amAttendPunch = this.getOne(Wrappers.<AttendPunch>lambdaQuery()
                .eq(AttendPunch::getCompanyId, companyId) //公司ID
                .eq(AttendPunch::getCompanyUserId, companyUserId) //员工ID
                .eq(AttendPunch::getEffectiveValid, true) //有效的
                .eq(AttendPunch::getPunchDateStr, DateTimeUtil.dateToStr(new Date(), DateTimeUtil.TIME_FORMAT_2))//当日
                .eq(AttendPunch::getPunchOnOffWork, AttendEnums.NOON_TYPE_MORNING.value()) //上午
        );

        //查询下午打卡数据
        AttendPunch pmAttendPunch = this.getOne(Wrappers.<AttendPunch>lambdaQuery()
                .eq(AttendPunch::getCompanyId, companyId) //公司ID
                .eq(AttendPunch::getCompanyUserId, companyUserId) //员工ID
                .eq(AttendPunch::getEffectiveValid, true) //有效的
                .eq(AttendPunch::getPunchDateStr, DateTimeUtil.dateToStr(new Date(), DateTimeUtil.TIME_FORMAT_2))//当日
                .eq(AttendPunch::getPunchOnOffWork, AttendEnums.NOON_TYPE_AFTERNOON.value()) //下午
        );

        AttendPunchUserWholeDayDTO dto = new AttendPunchUserWholeDayDTO();

        //拷贝数据
        if(amAttendPunch!=null){
            dto.setAttendPunchMorningResponse(BeanHelper.copyProperties(amAttendPunch, AttendPunchDTO.class));
        }

        if(pmAttendPunch!=null){
            dto.setAttendPunchAfterNoonResponse(BeanHelper.copyProperties(pmAttendPunch, AttendPunchDTO.class));
        }

        return dto;
    }
```

































