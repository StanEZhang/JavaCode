# 一、Java基础

## Java锁
https://www.yuque.com/u25361986/dp30lg/yup6kwby4zrw8gi9
## 重载和重写
重载是同一个方法名的不同的表现形式，表现为出入参数的不同。
重写是同一个方法的不同的实现形式，表现为方法内部逻辑的不同。

## 静态变量与实例变量

要单纯理解这两个概念的差异，基本上只要能理解类与对象的区别就差不多了。

**静态变量**在类中使用static关键字修饰的变量，static翻译为静态的，可以及理解为全局的，静态变量属于类而不属于对象。

静态变量存储在Method Area这个共享区域，而且只此一份，以便所有实例都能访问到同一个静态变量副本。

拓展：Method Area中存储类的定义、静态变量和常量等，常量存储在Method Area中的运行时常量池Runtime Constant Pool.常量大概就可以理解为是硬编码的固定值。

而**实例变量**是属于对象的，而对象是可以多次创建的，每创建一个对象就为分配一次内存空间，存储在Heap中。

## StringBuffer和StringBuilder

首先要知道String是不可变的（因为内部的Storage是字符数组，它被final修饰），而StringBuffer和StringBuilder是可变的，它们的内部也是字符数组，同样继承了AbstractStringBuilder，但是没有被final修饰。

他们俩的主要区别就是StringBuffer在它的方法中都加了synchronized关键字，也就是StringBuffer是线程安全的。

而正是因为synchronized的存在导致了它的性能会差一些。所以开发使用中就根据实际情况来决定用哪个。

## 字符与字符串的区别

字符是基本数据类型，存储单个字符，占2个字节，可以参与运算。字符串是引用数据类型。

## 值传递与引用传递

值传递就是你把参数（基本数据类型）传到方法里，传进去的是一个复制的值，你在方法里怎么改都不影响实际参数（方法外面哪个）。

引用传递就是你把参数（引用数据）的地址值传到方法里，形参和实参都指向同一个地址，你在方法里改，实际参数也会变化。



## 成员变量与局部变量

## IO流

## 深拷贝与浅拷贝

## \#和\$有什么区别


# 二、多线程

## 上下文切换

前后任务切换之间保存和加载的过程。

## 创建线程方式

1、继承 Thread 类；2、实现 Runnable 接口；3、实现 Callable接口；4、使用创建线程池
Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值。

## 线程池有7个参数

分别是核心线程数、最大线程数、阻塞队列、拒绝策略（丢弃任务抛异常、或不抛异常）、多余的空闲线程存活时间、时间单位、线程工厂（用于创建线程，默认即可）。然后当时我们核心线程数是10、最大线程数是100、阻塞队列是500、非核心线程生存时间是10秒，拒绝策略是让调用者执行任务。

**[强制]** 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。

说明:线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。

**[强制]** 线程池不允许使用 Executors 去创建，而是通过 **ThreadPoolExecutor** 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。

说明 : Executors 返回的线程池对象的弊端如下 :
1) FixedThreadPool和 SingleThreadPool允许的请求队列长度为 Integer.MAX VALUE，可能会堆积大量的请求，从而导致 OOM。
2) CachedThreadPool :允许的创建线程数量为 Integer.MAX VALUE，可能会创建大量的线程，从而导致 OOM。

 

## 线程的 run()和 start()区别

类似于百米赛跑的起跑和中途跑，start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。

## 线程的6种状态

新建状态（new）：创建线程对象。
就绪状态（runnable）：start方法。
阻塞状态（blocked）：无法获得锁对象（线程没抢到）。
等待状态（waiting）：wait方法。
计时状态（timed_waiting）：sleep方法。
死亡状态（terminated）：全部代码运行完毕。

## 线程的调度模式

分时调度：轮流获取CPU使用权。
抢占式调度：优先级高的线程占用CPU。

## wait、sleep、notify

（1）wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁，必须唤醒才能醒。
（2）sleep()：使一个正在运行的线程处于睡眠状态，不会释放资源。
（3）notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；
（4）notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

## ThreadLocal的原理

threadlocal是一个线程内部的存储类，内部维护了一个ThreadLocalMap，可以存储每个线程自己的数据。

## Executors 的弊端

会导致OOM内存溢出，阿里巴巴开发手册强制说明线程池不允许使用executors创建，而是通过ThreadPoolExecutor的方式。

# 三、JVM虚拟机

# 二、JavaWeb

## TCP和UDP的区别



## 你对HTTP协议的理解



## 拦截器和过滤器的区别



# 三、多线程



# 四、集合

## ArrayList 底层实现方式

①ArrayList中维护了一个Object类型的数组elementData.

transient Object[] elementData;// transient 表示瞬间，短暂的，表示该属性不会被序列化

②当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容器为0，第一次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍。

③如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍。

##  LinkedList 底层实现方式

①LinkedList底层维护了一个双向链表

②LinkedList中维护了两个属性first和last分别指向首节点和尾节点

③每个节点（Node对象），里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表

④所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。

## HashMap的底层实现原理

hashmap底层是数组+链表+红黑树，数组是采用一段连续的存储单元来存储的，
下面我们说底层原理如何实现：
当我们添加一个元素时，会得到一个key的哈希值，这个哈希值是key.hashCode()和它本身无符号右移得到的结果进行异或运算得到的结果，这个结果再跟数组长度-1进行与运算得到最终的索引值，这个索引值决定了我们添加的这个元素在table中的位置。
然后我们看这个位置是否已经有元素了，如果没有，就直接加上去。
如果有，就调用equals方法比较，如果相同，就放弃添加，如果不相同，则添加到最后。
在Java8中，如果一条链表的元素个数到达8，并且table大小>= 64，就会进行树化。
阿里开发手册推荐集合初始化时要指定集合初始值的大小，无法确定就设置16，扩容临界值是16*(loadFactor)0.75=12，扩容为自身的2倍长度。
然后我们具体讲一下确定元素索引值的算法。
首先h=key.hashCode()>>>16的目的是获取h的高16位，为什么需要高16位呢？
因为table长度是小于2^16的，参与与运算的始终是低16位，table长度不变的情况下，h的低位越随机，索引下标就会越散列，所以我们让h的高16位也参与运算。

## HashMap为什么数组长度始终是2的n次方

哈希值的范围值大概在±20亿左右，这个空间一般应用是很难碰撞的，但问题是内存放不下。所以这个散列值是不能直接用的，用之前要对数组长度进行取余运算，这里的话，因为hash%length==hash&(length-1)的前提是length是2的n次方，而二进制运算与相比于%能大大提高运算速度，所以就选择了与操作，所以就解释了长度为什么是2的n次方。

## 多线程下的HashMap线程安全吗

HashMap本身就是不安全的，多线程下，在添加元素时容易出现数据覆盖情况而丢失数据，也可能在扩容时，迁移数据出现数据覆盖情况而丢失数据。如若想要保证线程安全可以用ConcurrentHashMap.

## hashCode()与equals（）的相关规定

1.如果两个对象相等，则hashcode一定也是相同的

2.两个对象相等，对两个equals（）方法返回true

3.hashCode值相等，他们也不一定相等，比如通话=重地

4.hashCode（）默认行为是对堆上的对象产生独特值。如果不重写hashCode（），则对象无论如何都不会相等。

**hashCode的重写**

hashCode()和equal()一样都是基本类Object里的方法，而和equal()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值。

**equals方法的作用**

默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）；

要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。

## 如何选用集合

**存储键值对**，就用map,排序用treemap，不用排序用hashmap，保证线程安全用concurrentHashMap。

**存放元素值，**保证元素唯一用TreeSet或HashSet，不需要就选ArrayList或LinkedList。

# 五、Spring

## SpringMVC常用注解

@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。
@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
@Controller：设定SpringMVC的核心控制器bean

## 什么是Spring MVC

Spring MVC是一个基于Java的实现了MVC设计模式轻量级Web框架，通过把模型-视图-控制器分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。

## Spring MVC设定重定向和转发

（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"
（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"

## Spring IOC和AOP

IOC控制反转，某种技术的出现很定是为了解决某个问题，传统我们用三层架构开发，视图控制，业务逻辑，还有数据库操作，职责分的很清楚也容易维护。这样上层依赖下层，像controller依赖service，一个service被一百个controller使用，这样其实是做到了**逻辑复用**，但没有资源复用，为什么呢？上层调用下层的时候必然会持有下一层的对象引用，也就是成员变量，每个成员变量实例化一个对象，这样就造成了资源浪费。

那可能有人就会说，你对象重复创建，搞个单例模式不就好了，但你引入设计模式就让代码更复杂了，而且那么多累都是单例，大家都写一样的代码也很麻烦。

还有人会说，没事我服务器内存大，不差这点资源浪费，我就想这么写。

确实是这样的，三层架构写起来其实已经很方便了，但是还有另一个问题，写起来方便，那改起来呢？

有些组件的创建需要一系列配置，你要改配置，那跟这个组件相关的所有地方你都得改，那可就有的改了。

所以问题到底出在了什么地方？其实就是调用方参与了创建和配置工作，相当于我想吃饭的话我自己还得买菜做饭，很麻烦。

那怎么就不麻烦了呢？我们直接去餐馆，把做菜的控制权让出去，我们直接吃就行了。餐馆就是我们的IOC容器，这种做法就是**控制反转**。

交给容器管理的对象叫做Bean，是单例的，要用的时候直接获取Bean就行，怎么个获取法呢？我们直接按约定声明依赖项，Bean就自动配置好了，这就是**依赖注入**。

那那么是**AOP**？

之前说三层架构我们复用了业务逻辑，但是有一些辅助逻辑比如日志记录，性能统计这些逻辑你很难封装，我们写代码都是从上到下这样一条线，而这些辅助逻辑就穿插在这条线的各个地方，这条线有，那条线也有，所有业务逻辑在某个位置都有日志打印，这样我们想象一下，这些辅助逻辑就好像把业务逻辑横向给切开了，我们可以把这些逻辑看成是切面。

AOP的意思就是面向切面编程，OOP是纵向的，AOP是横向的，作为对OOP的补充。AOP 能让我们在不修改原来代码的基础上，让切面 的辅助逻辑在所有业务逻辑中生效。

举个例子，我们可以再某个位置声明一个切面（@Aspect），里面写清楚你原业务方法执行前你要做什么，执行后你要干什么，然后不管你几百几千个业务方法，我们就写这一次，就很快。

## 依赖注入方式

接口注入

构造方法注入

setter方法注入

# 六、SpringBoot

## springBoot优点 

–**独立运行** Spring Boot 而且内嵌了各种 servlet 容器，Tomcat

–**简化配置** spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置，**避免大量的 Maven 导入和各种版本冲突** 。

–**自动配置** Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean， 如添加一个 spring-boot-starter-web 启动器就能拥有 web 的功能，无 需其他配置。 

–无代码生成和 XML 配置 Spring Boot 配置过程中无代码生成，也无需 XML 

## SpringBoot启动时做了什么

1. SpringBoot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值 
2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进 行自动配置工作； 
3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar 包中； 

4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的组件 ， 并配置好这些组件 ； 

5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；

## 核心注解SpringBootApplication

SpringBootApplication，由 3 个注解组成： 

• @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。 

 @SpringBootConfiguration 跟进去发现，其就等价于@Configuration，@Configuration 本质上也就是一个@Component，也是一个组件而已。

• @EnableAutoConfiguration：打开自动配置的功能，给容器导入 META-INF/spring.factories 里定义的自动配 置类。 

• @ComponentScan：允许程序自动扫描包，扫描当前包及其子包下标注了@Component，@Controller，@Service，@Repository 类并纳入到 spring 容器中进行管理。

## starter

相关组件的自动导入与配置

## 配置文件加载顺序

1. config/application.properties（项目根目录中 config 目录下） 
2. config/application.yml 
3. application.properties（项目根目录下） 
4. application.yml 
5. resources/config/application.properties（项目 resources 目录中 config 目 录下 
6. resources/config/application.yml 
7. **resources/application.properties（项目的 resources 目录下）** 
8. **resources/application.yml**

# SpringCloud

## Nacos

# 七、MySQL

## 索引类型

**show index from 表名**——查看索引

**添加索引：alter table 表名 add 索引类型 （“列”）**

1，普通索引Index index_name：普通索引是最基本的索引，值可以为空；仅加速查询。
2，唯一索引unique：唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
3，主键索引primary key：主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。
4，联合索引：联合索引指在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。**alter table 表名 add Index 'user_index_username_password' ('username', 'password')**

触发联合索引：

①使用全部索引键可触发（where and）

②使用全部索引建但用where or连接 不可触发

③单独用联合索引左边第一个字段，可触发

④单独使用联合索引其他字段，不可触发

5，全文索引**fulltext**：全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。

## 索引失效

**索引列参与表达式计算：** 

SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30; 

• **where子句中加函数的**

SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) < 1990; 

**• %词语%–模糊查询：** 

SELECT * FROM 'manong' WHERE `uname` LIKE '码农%' -- 走索引 

SELECT * FROM 'manong' WHERE `uname` LIKE '%码农%' -- 不走索引 

**• 查询条件中有 or ，即使其中有条件带索引也不会使用**。换言之，就是要求使 

用的所有字段，都必须建立索引： 

select * from dept where dname='xxx' or loc='xx' or deptno = 45; 

• 正则表达式不使用索引。 

## 索引优化

在sql前面加上`explain`关键字，就能够看到它的执行计划，通过执行计划，我们可以清楚的看到表和索引执行的情况，索引有没有执行、索引执行顺序和索引的类型等。

1.   1.先用慢查询日志定位具体需要优化的sql

     **2.使用explain执行计划查看索引使用情况**

     3.重点关注：

   ​    key（查看有没有使用索引）

   ​    possible keys 指出是用哪个索引能在表中找打行

   ​    key_len（查看索引使用是否充分）当查询语句中的条件列可以使用索引时，`key_len` 的值越小，表示需要扫描的索引数据越少，					查询效率越高。

   ​    type（查看索引类型）

   ​       **system**:该表只有一行

   ​       **const**：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据

   ​       **eq_ref**：对于每个来自于前面的表的行组合，从该表中读取一行。

   ​       **ref**：所有有匹配索引值的行将从这张表中读取。

     一般情况下根据这4列就能找到索引问题。

     4.根据上1步找出的索引问题优化sql

     5.再回到第2步

## sql语句优化

1.避免使用select *

2.批量插入数据

3.多用limit

4.高效的分页

select id,name,age  from user where id > 1000000 limit 20;

5.用连接查询代替子查询

6.join的表不超过3个（阿里）

7.读写分离，主库写，从库读

## 表设计优化

1.所有表是用Innodb存储引擎

2.字符集统一用UTF-8，兼容性好，emoji(UTF8mb4)

3.数据量大小控制在500万以内，大了就分库分表

4.冷热数据分离

5.禁止存图片，文件大的二进制数据，存到文件服务器

6.单表索引不超过5个

7.禁止每一列都建单独的索引





## 事务的四个特征

（1）原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做

（2）一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。

（3）隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

（4）持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## 数据库并发脏读幻读

（1）脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

（2）不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

（3）幻读：假设系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

## 4个隔离级别

读取未提交：最低隔离级别，3种都会发生

读取已提交：防止脏读

可重复读：阻止脏读和不可重复读

可串行化：最高隔离级别，完全服从ACID，全部阻止

## 项目事务问题

大事务引发的问题

- 死锁
- 回滚时间长
- 并发情况下数据库连接池被占满
- 锁等待
- 接口超时
- 数据库主从延迟 

1. 少用@Transactional注解
2. 将查询(select)方法放到事务外
3. 事务中避免远程调用
4. 事务中避免一次性处理太多数据
5. 非事务执行
6. 异步处理

## MySQL存储引擎

MyISAM：不支持事务，表级锁，不支持外键，批量插入速度比较快

InnoDB：支持事务，默认行级锁，支持外键（B+树，具有B树的平衡性，提高区间查询性能）

## drop、delete、truncate

drop table 表名——将表删除掉

truncate table 表名—— 清空表（不删除表结构）

delete: delete from 表名 where 列名=值

## 查询第n高的工资（不重复记录）

**select** **distinct**(salary) from employee **order** **by** salary **desc** **limit** n-1, 1

limit 只接受正整数，不接受表达式，所以set N := N-1;

SELECT salary FROM employee GROUP BY salary ORDER BY salary DESC LIMIT N, 1

# 八、Redis

## 穿透和雪崩

**缓存穿透**（恶意攻击或代码逻辑错误）

如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃。

解决：

缓存空数据，但key一直变，设置过期时间，布隆过滤器

**缓存雪崩**

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。阿里的人说可以 判断 是否过期，如果过期迅速返回指定错误，服务端 发现指定错误之后，立即进行相应处理，不在访问数据库。

**设置缓存超时时间的时候加上一个随机的时间长度，比如这个缓存key的超时时间是固定的5分钟加上随机的2分钟**

## 5种数据结构

**String** 

string 数据结构是简单的 key-value 类型。常用命令： set,get,setex 等等。 可以用来计数。

**• List**

–介绍 ：**list** 即是 **链表**。特点是插入和删除效率高，但是链表的随机访问困难。

–常用命令: rpush,lpop,lpush,rpop等。 

–应用场景: 发布与订阅或者说消息队列。 

• **Hash**

key-field-value

**适合用于存储对象**，比如存储用户信息，商品信息等等。

–常用命令：hset，hget等。 

• **Set**

无序 集合，集合中的元素没有先后顺序。

常用命令：sadd,spop等。 

• **SortedSet**(zset)

–介绍：SortedSet 和 set 相比，SortedSet 增加了一个权重参数 score，使得 

集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来 

获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 

–常用命令：zadd,zrange,zrevrange等。 

–应用场景： 各种礼物排行榜。

## 过期删除策略

常用的过期数据的删除策略就两个： 

• **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查，但是可能会造成太多过期 key 没有被删除。 

• **定期删除** ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。

## 内存淘汰策略

从已设置过期时间的数据集中挑选最近**最少使用的**数据淘汰 

从已设置过期时间的数据集中挑选**将要过期的**数据淘汰 

从**已设置过期时间的**数据集中任意选择 数据淘汰  

禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，**新写入操作会报错**。这个应该没人使用吧！



# 消息队列

# Linux